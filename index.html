<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE-edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Skipper CNFTs</title>
<style>

* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}

canvas {
	 position:  absolute;
	 top:  0;
	 left: 0;
}

body {
	overflow:  hidden;
}

</style>

<body>
	<div><canvas id='canvas1' style="object-fit: contain; width: 100vw; height: 100vh"; width="550" height="550"></canvas></div>
 
  
  
<script>
//Get Random Colour function
function getRandomColor() {
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
              }
              return color;
            };

//Random Integer function
function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1) + min);
          };
//Set up canvas 

	const canvas = document.getElementById('canvas1');
	const ctx = canvas.getContext('2d');
	canvas.width = 550;
	canvas.height = 550;
	canvas.style.width = '100vw';
  canvas.style.height = '100vh';
  canvas.style.transform = "rotate(270deg)";         // or -90 depending on need
  canvas.style.webkitTransform = "rotate(270deg)";
  ctx.fillStyle='black';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  document.body.style.backgroundColor = 'black';

//Create Symbols and apply Effect

	class Symbol {
		constructor(x, y, fontSize, canvasHeight){
			this.characters = '01';
			this.x = x;
			this.y = y;
			this.fontSize = fontSize;
			this.text = '';
			this.canvasHeight = canvasHeight;

		}
		draw(context){
			this.text = this.characters.charAt(Math.floor(Math.random()*this.characters.length));
			context.fillText(this.text, this.x * this.fontSize, this.y * this.fontSize);
			if (this.y * this.fontSize > this.canvasHeight && Math.random() > 0.1){
				this.y = 0;
			} else {
				this.y += 1;
			}

		}
	}

	class Effect {
		constructor(canvasWidth, canvasHeight){
			this.canvasWidth = canvasWidth;
			this.canvasHeight = canvasHeight;
			this.fontSize = 1;
			this.columns = this.canvasWidth/this.fontSize;
			this.symbols = [];
			this.#initialize();

		}
		#initialize(){
			for (let i = 0; i < this.columns; i++){
				this.symbols[i] = new Symbol(i, 0, this.fontSize, this.canvasHeight); 
			}
		}
		resize(width, height){
			this.canvasWidth = width;
			this.canvasHeight = height;
			this.columns = this.canvasWidth/this.fontSize;
			this.symbols = [];
			this.#initialize();

		}
	}

const effect = new Effect(canvas.width, canvas.height);
let lastTime = 0;
const fps = 60;
const nextFrame = 2500/fps;
let timer = 0;


var colour_array = new Array (
	'darkRed',
	'red',
	'mediumVioletRed'
	)

//Animate Binary

function animate(timeStamp){
	const deltaTime = timeStamp - lastTime;
	lastTime = timeStamp;


	if (timer > nextFrame){
	ctx.fillStyle = 'rgba(0, 0, 0, 0.005)';
	ctx.textAlign = 'center';
	ctx.fillRect(0, 0, canvas.width/2, canvas.height/2);
	ctx.fillStyle = colour_array[getRandomInt(0,2)];
	ctx.font = effect.fontSize + 'px monospace';
	effect.symbols.forEach(symbol => symbol.draw(ctx));
	effect.symbols.forEach(symbol => symbol.draw(ctx));
	
	ctx.translate(canvas.width/2, canvas.height/2);
	ctx.rotate(Math.PI / 35);
	ctx.rotate(Math.PI / 130);
	ctx.translate(-canvas.width/2, -canvas.height/2);

	timer = 0;	
	} else {
		timer += deltaTime;
	}
	requestAnimationFrame(animate);
}

animate(0);


//Event Listener for Resize
window.addEventListener('resize', function(){
			canvas.width = 550;
			canvas.height = 550;
			effect.resize(canvas.width, canvas.height);
})

//Event Listener for Click
      canvas.addEventListener(
        "click",
        function (event) {

          if (!event.target.matches('.canvas')) {

        location.reload();
          }

        },
        false
      );

</script>
</body>
</html>
